<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>theory package &mdash; SModelS 1.0.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="SModelS 1.0.3 documentation" href="index.html" />
    <link rel="next" title="experiment package" href="experiment.html" />
    <link rel="prev" title="SModelS Documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="experiment.html" title="experiment package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="SModelS Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">SModelS 1.0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="theory-package">
<h1>theory package<a class="headerlink" href="#theory-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-theory.analysis">
<span id="theory-analysis-module"></span><h2>theory.analysis module<a class="headerlink" href="#module-theory.analysis" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.analysis"></span><dl class="class">
<dt id="theory.analysis.EManalysis">
<em class="property">class </em><tt class="descname">EManalysis</tt><a class="reference internal" href="_modules/theory/analysis.html#EManalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.EManalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">smodels.theory.printer.Printer</span></tt></p>
<p>Class to store a efficiency map-type of analysis.    
Stores the basic analysis info and contains a method for obtaining the
efficiency maps from the database.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>label</strong> &#8211; Analysis label/name</li>
<li><strong>sqrts</strong> &#8211; Analysis center-of-mass energy</li>
<li><strong>lum</strong> &#8211; Analysis luminosity</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.analysis.EManalysis.getEfficiencyFor">
<tt class="descname">getEfficiencyFor</tt><big>(</big><em>element</em><big>)</big><a class="reference internal" href="_modules/theory/analysis.html#EManalysis.getEfficiencyFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.EManalysis.getEfficiencyFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get efficiency for element from the database.        
Returns zero if a efficiency is not found.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">not implemented yet</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">efficiency value (float). zero, if element is not found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.analysis.EManalysis.getLimitFor">
<tt class="descname">getLimitFor</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/analysis.html#EManalysis.getLimitFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.EManalysis.getLimitFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get experimental limit for a cross-section.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">not implemented yet</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">experimental upper limit for cross-section
(float with unit or Unum object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.analysis.ULanalysis">
<em class="property">class </em><tt class="descname">ULanalysis</tt><a class="reference internal" href="_modules/theory/analysis.html#ULanalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.ULanalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">smodels.theory.printer.Printer</span></tt></p>
<p>Class to store one upper limit-type analysis.    
Stores the conditions and the elements constrained by the analysis as well
as basic analysis info.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>conditions</strong> &#8211; List of conditions strings</li>
<li><strong>constraint</strong> &#8211; Constraint string</li>
<li><strong>elementsEff</strong> &#8211; Dictionary with constrained elements as keys and
efficiencies as values</li>
<li><strong>label</strong> &#8211; Analysis label/name</li>
<li><strong>sqrts</strong> &#8211; Analysis center-of-mass energy</li>
<li><strong>lum</strong> &#8211; Analysis luminosity</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.analysis.ULanalysis.formatData">
<tt class="descname">formatData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/analysis.html#ULanalysis.formatData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.ULanalysis.formatData" title="Permalink to this definition">¶</a></dt>
<dd><p>Select data preparation method through dynamic binding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.analysis.ULanalysis.getBranchCondition">
<tt class="descname">getBranchCondition</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/analysis.html#ULanalysis.getBranchCondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.ULanalysis.getBranchCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Most analyses include assumptions about the masses of the elements
appearing in their constraints.
This method returns a string describing this condition</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">string describing branch condition (from the branchcondition field)
or None if no condition is found</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.analysis.ULanalysis.getEfficiencyFor">
<tt class="descname">getEfficiencyFor</tt><big>(</big><em>element</em><big>)</big><a class="reference internal" href="_modules/theory/analysis.html#ULanalysis.getEfficiencyFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.ULanalysis.getEfficiencyFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get (trivial) efficiency for element.        
Returns zero if element is not constrained by the analysis or the
element multiplicative factor if it is.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">1 if element is in constraint, zero otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.analysis.ULanalysis.getUpperLimitFor">
<tt class="descname">getUpperLimitFor</tt><big>(</big><em>mass</em><big>)</big><a class="reference internal" href="_modules/theory/analysis.html#ULanalysis.getUpperLimitFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.analysis.ULanalysis.getUpperLimitFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the experimental upper limit for a specific mass array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mass</strong> &#8211; mass vector for computing the upper limit</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">experimental upper limit for cross-section times BR (float with unit or Unum object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory.auxiliaryFunctions">
<span id="theory-auxiliaryfunctions-module"></span><h2>theory.auxiliaryFunctions module<a class="headerlink" href="#module-theory.auxiliaryFunctions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.auxiliaryFunctions"></span><dl class="function">
<dt id="theory.auxiliaryFunctions.cGtr">
<tt class="descname">cGtr</tt><big>(</big><em>weightA</em>, <em>weightB</em><big>)</big><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#cGtr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.cGtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the auxiliary greater function.</p>
<p>Return a number between 0 and 1 depending on how much it is violated
(0 = A &gt; B, 1 = A &lt;&lt; B).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">XSectioList object with the values for each label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.cSim">
<tt class="descname">cSim</tt><big>(</big><em>*weights</em><big>)</big><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#cSim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.cSim" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the auxiliar similar function.</p>
<p>Return the maximum relative difference between any element weights of the
list, normalized to [0,1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">XSectionList object with the values for each label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.distance">
<tt class="descname">distance</tt><big>(</big><em>xmass1</em>, <em>xmass2</em><big>)</big><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Define distance between two mass positions in upper limit space.
The distance is defined as d = 2*|xmass1-xmass2|/(xmass1+xmass2).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xmass1</strong> &#8211; upper limit value (in fb) for the mass1</li>
<li><strong>xmass2</strong> &#8211; upper limit value (in fb) for the mass2</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">relative mass distance in upper limit space</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.massAvg">
<tt class="descname">massAvg</tt><big>(</big><em>massList</em>, <em>method='weighted'</em>, <em>weights=None</em><big>)</big><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#massAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.massAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average mass of massList according to method.</p>
<p>If method=weighted but weights were not properly defined,
switch method to harmonic.    
If massList contains a zero mass, switch method to mean.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; possible values: harmonic, mean, weighted</li>
<li><strong>weights</strong> &#8211; weights of elements (only for weighted average)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.massPosition">
<tt class="descname">massPosition</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#massPosition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.massPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Give mass position in upper limit space.    
Use the analysis experimental limit data.</p>
</dd></dl>

</div>
<div class="section" id="module-theory.branch">
<span id="theory-branch-module"></span><h2>theory.branch module<a class="headerlink" href="#module-theory.branch" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.branch"></span><dl class="class">
<dt id="theory.branch.Branch">
<em class="property">class </em><tt class="descname">Branch</tt><big>(</big><em>info=None</em><big>)</big><a class="reference internal" href="_modules/theory/branch.html#Branch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a branch.    
A branch-element can be constructed from a string (e.g., (&#8216;[b,b],[W]&#8217;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>masses</strong> &#8211; list of masses for the intermediate states</li>
<li><strong>particles</strong> &#8211; list of particles (strings) for the final states</li>
<li><strong>momID</strong> &#8211; PDG id for the primary (intermediate state) mother</li>
<li><strong>daughterID</strong> &#8211; PDG id for the last intermediate state</li>
<li><strong>maxWeight</strong> &#8211; weight of the branch (XSection object)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.branch.Branch.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/branch.html#Branch.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an independent copy of self.        
Faster than deepcopy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Branch object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.decayDaughter">
<tt class="descname">decayDaughter</tt><big>(</big><em>brDictionary</em>, <em>massDictionary</em><big>)</big><a class="reference internal" href="_modules/theory/branch.html#Branch.decayDaughter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.decayDaughter" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all new branches generated by the 1-step cascade
decay of the current branch daughter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>brDictionary</strong> &#8211; dictionary with the decay information
for all intermediate states (values are br objects, see pyslha)</li>
<li><strong>massDictionary</strong> &#8211; dictionary containing the masses for all intermediate states.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of extended branches (Branch objects). Empty list if daughter is stable or
if daughterID was not defined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.getLength">
<tt class="descname">getLength</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/branch.html#Branch.getLength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.getLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the branch length (= number of R-odd masses).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">length of branch (number of cascade decay steps)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.isEqual">
<tt class="descname">isEqual</tt><big>(</big><em>other</em>, <em>useDict=True</em><big>)</big><a class="reference internal" href="_modules/theory/branch.html#Branch.isEqual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.isEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two branches. If particles are similar
and masses are equal, return True. Otherwise, return False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; branch to be compared (Branch object)</li>
<li><strong>useDict</strong> &#8211; if True, allow for inclusive particle labels</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True if branches are equal (particles and masses match); False otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.branch.decayBranches">
<tt class="descname">decayBranches</tt><big>(</big><em>branchList, brDictionary, massDictionary, sigcut=0.00E+00 [fb]</em><big>)</big><a class="reference internal" href="_modules/theory/branch.html#decayBranches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.decayBranches" title="Permalink to this definition">¶</a></dt>
<dd><p>Decay all branches from branchList until all unstable intermediate states have decayed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>branchList</strong> &#8211; list of Branch() objects containing the initial mothers</li>
<li><strong>brDictionary</strong> &#8211; dictionary with the decay information
for all intermediate states (values are br objects, see pyslha)</li>
<li><strong>massDictionary</strong> &#8211; dictionary containing the masses for all intermediate states.</li>
<li><strong>sigcut</strong> &#8211; minimum sigma*BR to be generated, by default sigcut = 0.
(all branches are kept)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of branches (Branch objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.clusterTools">
<span id="theory-clustertools-module"></span><h2>theory.clusterTools module<a class="headerlink" href="#module-theory.clusterTools" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.clusterTools"></span><dl class="class">
<dt id="theory.clusterTools.ElementCluster">
<em class="property">class </em><tt class="descname">ElementCluster</tt><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a cluster.    
This class is used to store the relevant information about a cluster of
elements and to manipulate this information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>elements</strong> &#8211; list of elements in the cluster (Element objects)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getAvgMass">
<tt class="descname">getAvgMass</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getAvgMass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getAvgMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average mass of all elements belonging to the cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">average mass array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getTotalXSec">
<tt class="descname">getTotalXSec</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getTotalXSec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getTotalXSec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum over the cross-sections of all elements belonging to
the cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">sum of weights of all the elements in the cluster (XSectionList object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.clusterTools.IndexCluster">
<em class="property">class </em><tt class="descname">IndexCluster</tt><big>(</big><em>massMap=None</em>, <em>posMap=None</em>, <em>wMap=None</em>, <em>indices=set([])</em>, <em>analysis=None</em><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a cluster storing element indices.    
This auxiliary class is used to store element indices and positions in
upper limit space. It is only used by the clustering algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>indices</strong> &#8211; list of integers mapping the cluster elements to their position in the list
(1st element -&gt; index 0, 2nd element -&gt; index 1,...)</li>
<li><strong>avgPosition</strong> &#8211; position in upper limit space for the cluster average mass</li>
<li><strong>massMap</strong> &#8211; dictionary with indices as keys and the corresponding element mass as values</li>
<li><strong>positionMap</strong> &#8211; dictionary with indices as keys and the corresponding element position
in upper limit space as values</li>
<li><strong>weightMap</strong> &#8211; dictionary with indices as keys and the corresponding element weight
as values</li>
<li><strong>analysis</strong> &#8211; analysis to which the cluster applies (ULanalysis object)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.clusterTools.IndexCluster.add">
<tt class="descname">add</tt><big>(</big><em>iels</em><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an index or a list of indices to the list of indices and update
the avgPosition value.</p>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.IndexCluster.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the index cluster (faster than deepcopy).</p>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.IndexCluster.remove">
<tt class="descname">remove</tt><big>(</big><em>iels</em><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an index or a list of indices to the list of indices and
update the avgPosition value.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.clusterTools.clusterElements">
<tt class="descname">clusterElements</tt><big>(</big><em>elements</em>, <em>analysis</em>, <em>maxDist</em><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#clusterElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.clusterElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster the original elements according to their mass distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>elements</strong> &#8211; list of elements (Element objects)</li>
<li><strong>analysis</strong> &#8211; analysis to be considered (must be a ULanalysis object)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of clusters (ElementCluster objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.clusterTools.groupAll">
<tt class="descname">groupAll</tt><big>(</big><em>elements</em><big>)</big><a class="reference internal" href="_modules/theory/clusterTools.html#groupAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.groupAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a single cluster containing all the elements.</p>
</dd></dl>

</div>
<div class="section" id="module-theory.crossSection">
<span id="theory-crosssection-module"></span><h2>theory.crossSection module<a class="headerlink" href="#module-theory.crossSection" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.crossSection"></span><dl class="class">
<dt id="theory.crossSection.XSection">
<em class="property">class </em><tt class="descname">XSection</tt><a class="reference internal" href="_modules/theory/crossSection.html#XSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a cross-section.</p>
<p>This class is used to store the information of a single cross-section
(value, paritcle ids, center of mass, order and label).</p>
<p>order = 0 (LO), 1 (NLO) or 2 (NLL).</p>
<dl class="method">
<dt id="theory.crossSection.XSection.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSection.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSection.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an independent copy of self.</p>
<p>Faster than deepcopy.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSection.niceStr">
<tt class="descname">niceStr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSection.niceStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSection.niceStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a more human readable string. The string format is:
Sqrts: self.info.sqrts,  Weight: self.value</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.crossSection.XSectionInfo">
<em class="property">class </em><tt class="descname">XSectionInfo</tt><a class="reference internal" href="_modules/theory/crossSection.html#XSectionInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents information regarding a cross-section.</p>
<p>This class is used to store information of a cross-section (center of
mass, order and label).</p>
<dl class="method">
<dt id="theory.crossSection.XSectionInfo.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionInfo.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionInfo.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an independent copy of self.</p>
<p>Faster than deepcopy.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.crossSection.XSectionList">
<em class="property">class </em><tt class="descname">XSectionList</tt><big>(</big><em>infoList=None</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a list of cross-sections.</p>
<p>This class is used to store a list of cross-sections.</p>
<dl class="method">
<dt id="theory.crossSection.XSectionList.add">
<tt class="descname">add</tt><big>(</big><em>newxsec</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a XSection object to the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.combineWith">
<tt class="descname">combineWith</tt><big>(</big><em>newXsecs</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.combineWith"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.combineWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new list of cross-sections.</p>
<p>If the new cross-sections already appear (have same order and sqrts),
add its value to the original value, otherwise append it to the list.
The particle IDs are ignored when adding cross-sections. Hence, they
are set to (None, None) if any cross-sections are combined.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an independent copy of itself. Faster than deepcopy.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.delete">
<tt class="descname">delete</tt><big>(</big><em>xSec</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the cross-section entry from the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getDictionary">
<tt class="descname">getDictionary</tt><big>(</big><em>groupBy='pids'</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getDictionary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getDictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the list of XSection objects to a nested dictionary.</p>
<p>First level keys are the particles IDs (if groupBy == pids) or labels
(if groupBy == labels) and values are the cross-section labels or
particle IDs and the cross-section value.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getInfo">
<tt class="descname">getInfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get basic info about the cross-sections appearing in the list (order,
value and label).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of XSectionInfo objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getMaxXsec">
<tt class="descname">getMaxXsec</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getMaxXsec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getMaxXsec" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum cross-section value appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getMinXsec">
<tt class="descname">getMinXsec</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getMinXsec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getMinXsec" title="Permalink to this definition">¶</a></dt>
<dd><p>Get minimum cross-section value appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getPIDpairs">
<tt class="descname">getPIDpairs</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getPIDpairs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getPIDpairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all particle ID pairs appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getPIDs">
<tt class="descname">getPIDs</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getPIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getPIDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all particle IDs appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getXsecsFor">
<tt class="descname">getXsecsFor</tt><big>(</big><em>item</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getXsecsFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getXsecsFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of XSection objects for item (label, pid, sqrts).</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.niceStr">
<tt class="descname">niceStr</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.niceStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.niceStr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.order">
<tt class="descname">order</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Order the cross-section in the list by their PDG pairs</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.removeLowerOrder">
<tt class="descname">removeLowerOrder</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.removeLowerOrder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.removeLowerOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the highest order cross-section for each process in the list.</p>
<p>Remove order information and set default labels.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.crossSection.getXsecFromLHEFile">
<tt class="descname">getXsecFromLHEFile</tt><big>(</big><em>lhefile</em>, <em>addEvents=True</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#getXsecFromLHEFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.getXsecFromLHEFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain cross-sections from input LHE file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhefile</strong> &#8211; LHE input file with unweighted MC events</li>
<li><strong>addEvents</strong> &#8211; if True, add cross-sections with the same mothers,
otherwise return the event weight for each pair of mothers</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a XSectionList object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.crossSection.getXsecFromSLHAFile">
<tt class="descname">getXsecFromSLHAFile</tt><big>(</big><em>slhafile, useXSecs=None, xsecUnit=1.00E+00 [pb]</em><big>)</big><a class="reference internal" href="_modules/theory/crossSection.html#getXsecFromSLHAFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.getXsecFromSLHAFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain cross-sections for pair production of R-odd particles from input SLHA file.
The default unit for cross-section is pb.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>slhafile</strong> &#8211; SLHA input file with cross-sections</li>
<li><strong>useXSecs</strong> &#8211; if defined enables the user to select cross-sections to
use. Must be a XSecInfoList object</li>
<li><strong>xsecUnit</strong> &#8211; cross-section unit in the input file (must be a Unum unit)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a XSectionList object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.element">
<span id="theory-element-module"></span><h2>theory.element module<a class="headerlink" href="#module-theory.element" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.element"></span><dl class="class">
<dt id="theory.element.Element">
<em class="property">class </em><tt class="descname">Element</tt><big>(</big><em>info=None</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">smodels.theory.printer.Printer</span></tt></p>
<p>An instance of this class represents an element.    
This class possesses a pair of branches and the element weight
(cross-section * BR).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>branches</strong> &#8211; list of branches (Branch objects)</li>
<li><strong>weight</strong> &#8211; element weight (cross-section * BR)</li>
<li><strong>motherElements</strong> &#8211; only for elements generated from a parent element
by mass compression, invisible compression,etc.
Holds a pair of (whence, mother element), where
whence describes what process generated the element</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.element.Element.checkConsistency">
<tt class="descname">checkConsistency</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.checkConsistency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.checkConsistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the particles defined in the element exist and are consistent
with the element info.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the element is consistent. Print error message
and exits otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.combineMotherElements">
<tt class="descname">combineMotherElements</tt><big>(</big><em>el2</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.combineMotherElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.combineMotherElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine mother elements from self and el2 into self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>el2</strong> &#8211; element (Element Object)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.compressElement">
<tt class="descname">compressElement</tt><big>(</big><em>doCompress</em>, <em>doInvisible</em>, <em>minmassgap</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.compressElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.compressElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep compressing the original element and the derived ones till they
can be compressed no more.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>doCompress</strong> &#8211; if True, perform mass compression</li>
<li><strong>doInvisible</strong> &#8211; if True, perform invisible compression</li>
<li><strong>minmassgap</strong> &#8211; value (in GeV) of the maximum 
mass difference for compression
(if mass difference &lt; minmassgap, perform mass compression)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list with the compressed elements (Element objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of self.        
Faster than deepcopy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">copy of element (Element object)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.formatData">
<tt class="descname">formatData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.formatData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.formatData" title="Permalink to this definition">¶</a></dt>
<dd><p>Select data preparation method through dynamic binding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getDaughters">
<tt class="descname">getDaughters</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.getDaughters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getDaughters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pair of daughter IDs (PDGs of the last intermediate state appearing the cascade decay).    
Can be None, if the element does not have a definite daughter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of PDG ids</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getEinfo">
<tt class="descname">getEinfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.getEinfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getEinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get topology info from particle string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionary containing vertices and number of final states information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getMasses">
<tt class="descname">getMasses</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.getMasses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getMasses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the array of masses in the element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of masses (mass array)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getMothers">
<tt class="descname">getMothers</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.getMothers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getMothers" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pair of mother IDs (PDG ids of the primary mother intermediate state).      
Can be None, if the element does not have a definite mother.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of PDG ids</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getParticles">
<tt class="descname">getParticles</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.getParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the array of particles in the element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of particle strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.hasTopInList">
<tt class="descname">hasTopInList</tt><big>(</big><em>elementList</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.hasTopInList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.hasTopInList" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the element topology matches any of the topologies in the
element list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elementList</strong> &#8211; list of elements (Element objects)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True, if element topology has a match in the list, False otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.invisibleCompress">
<tt class="descname">invisibleCompress</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.invisibleCompress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.invisibleCompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform invisible compression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">compressed copy of the element, if element ends with invisible
particles; None, if compression is not possible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.isEqual">
<tt class="descname">isEqual</tt><big>(</big><em>other</em>, <em>order=False</em>, <em>useDict=True</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.isEqual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.isEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Elements for equality.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; element to be compared (Element object)</li>
<li><strong>order</strong> &#8211; if False, test both branch orderings.</li>
<li><strong>useDict</strong> &#8211; if True, allow for inclusive particle labels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True, if all masses and particles are equal; False, else;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.isInList">
<tt class="descname">isInList</tt><big>(</big><em>listOfElements</em>, <em>igmass=False</em>, <em>useDict=True</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.isInList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.isInList" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the element is present in the element list.</p>
<p>:parameter      
If igmass == False also check if the analysis has the element mass
array.</p>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.massCompress">
<tt class="descname">massCompress</tt><big>(</big><em>minmassgap</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.massCompress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.massCompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform mass compression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>minmassgap</strong> &#8211; value (in GeV) of the maximum 
mass difference for compression
(if mass difference &lt; minmassgap -&gt; perform mass compression)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">compressed copy of the element, if two masses in this
element are degenerate; None, if compression is not possible;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.particlesMatch">
<tt class="descname">particlesMatch</tt><big>(</big><em>other</em>, <em>order=False</em>, <em>useDict=True</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.particlesMatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.particlesMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Elements for matching particles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; element to be compared (Element object)</li>
<li><strong>order</strong> &#8211; if False, test both branch orderings.</li>
<li><strong>useDict</strong> &#8211; if True, allow for inclusive particle labels.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True, if particles match; False, else;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.setMasses">
<tt class="descname">setMasses</tt><big>(</big><em>mass</em>, <em>sameOrder=True</em>, <em>opposOrder=False</em><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.setMasses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.setMasses" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the element masses to the input mass array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mass</strong> &#8211; list of masses ([[masses for branch1],[masses for branch2]])</li>
<li><strong>sameOrder</strong> &#8211; if True, set the masses to the same branch ordering
If True and opposOrder=True, set the masses to the
smaller of the two orderings.</li>
<li><strong>opposOrder</strong> &#8211; if True, set the masses to the opposite branch ordering.
If True and sameOrder=True, set the masses to the
smaller of the two orderings.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.switchBranches">
<tt class="descname">switchBranches</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/element.html#Element.switchBranches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.switchBranches" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch branches, if the element contains a pair of them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">element with switched branches (Element object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory.lheDecomposer">
<span id="theory-lhedecomposer-module"></span><h2>theory.lheDecomposer module<a class="headerlink" href="#module-theory.lheDecomposer" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.lheDecomposer"></span><dl class="function">
<dt id="theory.lheDecomposer.decompose">
<tt class="descname">decompose</tt><big>(</big><em>lhefile, inputXsecs=None, nevts=None, doCompress=False, doInvisible=False, minmassgap=-1.00E+00 [GeV]</em><big>)</big><a class="reference internal" href="_modules/theory/lheDecomposer.html#decompose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheDecomposer.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform LHE-based decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhefile</strong> &#8211; LHE file with e.g. pythia events</li>
<li><strong>inputXsecs</strong> &#8211; xSectionList object with cross-sections for the mothers
appearing in the LHE file. If None, use information from file.</li>
<li><strong>nevts</strong> &#8211; (maximum) number of events used in the decomposition. If
None, all events from file are processed.</li>
<li><strong>doCompress</strong> &#8211; mass compression option (True/False)</li>
<li><strong>doInvisible</strong> &#8211; invisible compression option (True/False)</li>
<li><strong>minmassgap</strong> &#8211; minimum mass gap for mass compression (only used if
doCompress=True)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of topologies (TopologyList object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.lheDecomposer.elementFromEvent">
<tt class="descname">elementFromEvent</tt><big>(</big><em>event</em>, <em>weight=None</em><big>)</big><a class="reference internal" href="_modules/theory/lheDecomposer.html#elementFromEvent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheDecomposer.elementFromEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an element from a LHE event and the corresponding event weight.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event</strong> &#8211; LHE event</li>
<li><strong>weight</strong> &#8211; event weight. Must be a XSectionList object (usually with a
single entry) or None if not specified.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">element</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.lheReader">
<span id="theory-lhereader-module"></span><h2>theory.lheReader module<a class="headerlink" href="#module-theory.lheReader" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.lheReader"></span><dl class="class">
<dt id="theory.lheReader.LheReader">
<em class="property">class </em><tt class="descname">LheReader</tt><big>(</big><em>filename</em>, <em>nmax=None</em><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#LheReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a reader for LHE files.</p>
<dl class="method">
<dt id="theory.lheReader.LheReader.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#LheReader.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the lhe file, if open.</p>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.LheReader.event">
<tt class="descname">event</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#LheReader.event"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader.event" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">SmsEvent; None if no event is left to be read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.LheReader.next">
<tt class="descname">next</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#LheReader.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next element in iteration.</p>
<p>Needed for the iterator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.lheReader.Particle">
<em class="property">class </em><tt class="descname">Particle</tt><a class="reference internal" href="_modules/theory/lheReader.html#Particle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.Particle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a particle.</p>
</dd></dl>

<dl class="class">
<dt id="theory.lheReader.SmsEvent">
<em class="property">class </em><tt class="descname">SmsEvent</tt><big>(</big><em>eventnr=None</em><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Event class featuring a list of particles and some convenience functions.</p>
<dl class="method">
<dt id="theory.lheReader.SmsEvent.add">
<tt class="descname">add</tt><big>(</big><em>particle</em><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add particle to the event.</p>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.SmsEvent.getMom">
<tt class="descname">getMom</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent.getMom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent.getMom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pdgs of the mothers, None if a problem occurs.</p>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.SmsEvent.metaInfo">
<tt class="descname">metaInfo</tt><big>(</big><em>key</em><big>)</big><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent.metaInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent.metaInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the meta information of &#8216;key&#8217;, None if info does not exist.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory.particleNames">
<span id="theory-particlenames-module"></span><h2>theory.particleNames module<a class="headerlink" href="#module-theory.particleNames" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.particleNames"></span><dl class="function">
<dt id="theory.particleNames.elementsInStr">
<tt class="descname">elementsInStr</tt><big>(</big><em>instring</em><big>)</big><a class="reference internal" href="_modules/theory/particleNames.html#elementsInStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.elementsInStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse instring and return a list of elements appearing in instring.</p>
<p>instring can also be a list of strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of elements appearing in instring in string format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.getName">
<tt class="descname">getName</tt><big>(</big><em>pdg</em><big>)</big><a class="reference internal" href="_modules/theory/particleNames.html#getName"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pdg number to particle name according to the dictionaries rOdd and
rEven.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">particle name (e.g. gluino, mu-, ...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.getPdg">
<tt class="descname">getPdg</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/theory/particleNames.html#getPdg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.getPdg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a name to the pdg number according to the dictionaries rOdd and
rEven.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">particle pdg; None, if name could not be resolved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.simParticles">
<tt class="descname">simParticles</tt><big>(</big><em>ptype1</em>, <em>ptype2</em>, <em>useDict=True</em><big>)</big><a class="reference internal" href="_modules/theory/particleNames.html#simParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.simParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares 2 particle names or 2 nested name arrays. Allows for dictionary
labels (Ex: L = l, l+ = l, l = l-,...). For the last nested level ignore
particle ordering.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ptype1</strong> &#8211; first (nested) list of particle names, e.g. [&#8216;l&#8217;,&#8217;jet&#8217;]</li>
<li><strong>ptype2</strong> &#8211; second (nested) list of particle names</li>
<li><strong>useDict</strong> &#8211; use the translation dictionary, i.e. allow e to stand for
e+ or e-, l+ to stand for e+ or mu+, etc</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">boolean</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.vertInStr">
<tt class="descname">vertInStr</tt><big>(</big><em>instring</em><big>)</big><a class="reference internal" href="_modules/theory/particleNames.html#vertInStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.vertInStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses instring (or a list of strings) and returns the list of particle
vertices appearing in instring.</p>
</dd></dl>

</div>
<div class="section" id="module-theory.printer">
<span id="theory-printer-module"></span><h2>theory.printer module<a class="headerlink" href="#module-theory.printer" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.printer"></span><dl class="class">
<dt id="theory.printer.Printer">
<em class="property">class </em><tt class="descname">Printer</tt><a class="reference internal" href="_modules/theory/printer.html#Printer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Printer class for defining specific print options and format for objects.</p>
<dl class="method">
<dt id="theory.printer.Printer.formatData">
<tt class="descname">formatData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of the derived object.</p>
<p>Has to be implemented in the derived object. The real implementation is
selected through dynamic binding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">NotImplementedError</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatElementData">
<tt class="descname">formatElementData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatElementData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatElementData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of to print an element object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatMissingData">
<tt class="descname">formatMissingData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatMissingData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatMissingData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of missing topology list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatResultsData">
<tt class="descname">formatResultsData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatResultsData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatResultsData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of the final output object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatStatusData">
<tt class="descname">formatStatusData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatStatusData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatStatusData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of the output status object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatTheoryPredictionData">
<tt class="descname">formatTheoryPredictionData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatTheoryPredictionData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatTheoryPredictionData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of a TheoryPrediction object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatTopologyListData">
<tt class="descname">formatTopologyListData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatTopologyListData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatTopologyListData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data of to print Global topologies object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.formatULanalysisData">
<tt class="descname">formatULanalysisData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.formatULanalysisData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.formatULanalysisData" title="Permalink to this definition">¶</a></dt>
<dd><p>Format data for a ULanalysis object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.printer.Printer.printout">
<tt class="descname">printout</tt><big>(</big><em>target='stdout'</em>, <em>filename=''</em>, <em>outputLevel=1</em><big>)</big><a class="reference internal" href="_modules/theory/printer.html#Printer.printout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.printer.Printer.printout" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the content of the data structure to the target.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>target</strong> &#8211; The target to print to. Possible values: stdout, file.
Default: stdout.</li>
<li><strong>filename</strong> &#8211; Filename to which the output is written</li>
<li><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory.slhaDecomposer">
<span id="theory-slhadecomposer-module"></span><h2>theory.slhaDecomposer module<a class="headerlink" href="#module-theory.slhaDecomposer" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.slhaDecomposer"></span><dl class="function">
<dt id="theory.slhaDecomposer.decompose">
<tt class="descname">decompose</tt><big>(</big><em>slhafile, sigcut=1.00E-01 [fb], doCompress=False, doInvisible=False, minmassgap=-1.00E+00 [GeV], useXSecs=None</em><big>)</big><a class="reference internal" href="_modules/theory/slhaDecomposer.html#decompose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.slhaDecomposer.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform SLHA-based decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sigcut</strong> &#8211; minimum sigma*BR to be generated, by default sigcut = 0.1 fb</li>
<li><strong>doCompress</strong> &#8211; turn mass compression on/off</li>
<li><strong>doInvisible</strong> &#8211; turn invisible compression on/off</li>
<li><strong>minmassgap</strong> &#8211; maximum value (in GeV) for considering two R-odd particles
degenerate (only revelant for doCompress=True )</li>
<li><strong>useXSecs</strong> &#8211; optionally a dictionary with cross-sections for pair
production, by default reading the cross sections
from the SLHA file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of topologies (TopologyList object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.theoryPrediction">
<span id="theory-theoryprediction-module"></span><h2>theory.theoryPrediction module<a class="headerlink" href="#module-theory.theoryPrediction" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.theoryPrediction"></span><dl class="class">
<dt id="theory.theoryPrediction.TheoryPrediction">
<em class="property">class </em><tt class="descname">TheoryPrediction</tt><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPrediction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPrediction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents the results of the theory prediction
for an analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>analysis</strong> &#8211; holds the analysis (ULanalysis or EManalysis object)
to which the prediction refers to</li>
<li><strong>value</strong> &#8211; value of the theory prediction 
(relevant cross-section to be compared with the experimental limits).
It is a XSection object.</li>
<li><strong>conditions</strong> &#8211; list of values for the analysis conditions
(only for upper limit-type analysis, e.g. analysis=ULanalysis)</li>
<li><strong>mass</strong> &#8211; mass of the cluster to which the theory prediction refers to
(only for upper limit-type analysis, e.g. analysis=ULanalysis)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.theoryPrediction.TheoryPrediction.getmaxCondition">
<tt class="descname">getmaxCondition</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPrediction.getmaxCondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPrediction.getmaxCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum value from the list conditions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">maximum condition value (float)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.theoryPrediction.TheoryPredictionList">
<em class="property">class </em><tt class="descname">TheoryPredictionList</tt><big>(</big><em>theoryPredictions</em><big>)</big><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPredictionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPredictionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">smodels.theory.printer.Printer</span></tt></p>
<p>An instance of this class represents a collection of theory prediction
objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>_theoryPredictions</strong> &#8211; list of TheoryPrediction objects</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.theoryPrediction.TheoryPredictionList.formatData">
<tt class="descname">formatData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPredictionList.formatData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPredictionList.formatData" title="Permalink to this definition">¶</a></dt>
<dd><p>Select data preparation method through dynamic binding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.theoryPrediction.theoryPredictionFor">
<tt class="descname">theoryPredictionFor</tt><big>(</big><em>analysis</em>, <em>smsTopList</em>, <em>maxMassDist=0.2</em><big>)</big><a class="reference internal" href="_modules/theory/theoryPrediction.html#theoryPredictionFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.theoryPredictionFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute theory predictions for the given analysis, using the list of elements
in smsTopList.    
Collect elements and efficiencies, combine the masses (if needed) and
compute the conditions (if existing).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>analysis</strong> &#8211; analysis to be considered (ULanalysis or EManalysis object)</li>
<li><strong>smsTopList</strong> &#8211; list of topologies containing elements (TopologyList object)</li>
<li><strong>maxMassDist</strong> &#8211; maximum mass distance for clustering elements (float)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of TheoryPrediction objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.topology">
<span id="theory-topology-module"></span><h2>theory.topology module<a class="headerlink" href="#module-theory.topology" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.topology"></span><dl class="class">
<dt id="theory.topology.Topology">
<em class="property">class </em><tt class="descname">Topology</tt><big>(</big><em>elements=None</em><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>An instance of this class represents a topology.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>vertnumb</strong> &#8211; list with number of vertices in each branch</li>
<li><strong>verparts</strong> &#8211; list with number of final states in each branch</li>
<li><strong>elementList</strong> &#8211; list of Element objects with this common topology</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.topology.Topology.addElement">
<tt class="descname">addElement</tt><big>(</big><em>newelement</em><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology.addElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.addElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an Element object to the elementList.</p>
<p>For all the pre-existing elements, which match the new element, add
weight. If no pre-existing elements match the new one, add it to the
list. When comparing elements, try both branch orderings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newelement</strong> &#8211; element to be added (Element object)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True, if the element was added. False, otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.checkConsistency">
<tt class="descname">checkConsistency</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology.checkConsistency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.checkConsistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the all the elements in elementList are
consistent with the topology (same number of vertices and final states)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if all the elements are consistent. Print error message
and exits otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.describe">
<tt class="descname">describe</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology.describe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a detailed description of the topology.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of strings with a description of the topology</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.getElements">
<tt class="descname">getElements</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology.getElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.getElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of elements of the topology.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">elementList (list of Element objects)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.getTotalWeight">
<tt class="descname">getTotalWeight</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology.getTotalWeight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.getTotalWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all elements weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">sum of weights of all elements (XSection object)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.isEqual">
<tt class="descname">isEqual</tt><big>(</big><em>other</em>, <em>order=False</em><big>)</big><a class="reference internal" href="_modules/theory/topology.html#Topology.isEqual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.isEqual" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two topologies. Two topologies are equal if 
they have the same number of vertices and final states (in each vertex).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; topology to be compared (Topology object)</li>
<li><strong>order</strong> &#8211; if False, compare the two possible branch orderings.
If True, compare the two topologies assuming the same
branch ordering.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True, if both topologies equal; False, otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.topology.TopologyList">
<em class="property">class </em><tt class="descname">TopologyList</tt><big>(</big><em>topologies=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">smodels.theory.printer.Printer</span></tt></p>
<p>An instance of this class represents an iterable collection of topologies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>topos</strong> &#8211; list of topologies (Topology objects)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.topology.TopologyList.add">
<tt class="descname">add</tt><big>(</big><em>newTopology</em><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if elements in newTopology matches an entry in self.topos.</p>
<p>If it does, add weight. If the same topology exists, but not the same
element, add element. If neither element nor topology exist, add the
new topology and all its elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.addList">
<tt class="descname">addList</tt><big>(</big><em>topoList</em><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList.addList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.addList" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds topologies in topoList using the add method.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.describe">
<tt class="descname">describe</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList.describe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string with basic information about the topology list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.formatData">
<tt class="descname">formatData</tt><big>(</big><em>outputLevel</em><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList.formatData"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.formatData" title="Permalink to this definition">¶</a></dt>
<dd><p>Select data preparation method through dynamic binding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>outputLevel</strong> &#8211; general control for the output depth to be printed 
(0 = no output, 1 = basic output, 2 = detailed output,...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.getElements">
<tt class="descname">getElements</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList.getElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.getElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list with all the elements in all the topologies.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.getTotalWeight">
<tt class="descname">getTotalWeight</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/theory/topology.html#TopologyList.getTotalWeight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.getTotalWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all topologies total weights.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-theory" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.__init__"></span></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">theory package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-theory.analysis">theory.analysis module</a></li>
<li><a class="reference internal" href="#module-theory.auxiliaryFunctions">theory.auxiliaryFunctions module</a></li>
<li><a class="reference internal" href="#module-theory.branch">theory.branch module</a></li>
<li><a class="reference internal" href="#module-theory.clusterTools">theory.clusterTools module</a></li>
<li><a class="reference internal" href="#module-theory.crossSection">theory.crossSection module</a></li>
<li><a class="reference internal" href="#module-theory.element">theory.element module</a></li>
<li><a class="reference internal" href="#module-theory.lheDecomposer">theory.lheDecomposer module</a></li>
<li><a class="reference internal" href="#module-theory.lheReader">theory.lheReader module</a></li>
<li><a class="reference internal" href="#module-theory.particleNames">theory.particleNames module</a></li>
<li><a class="reference internal" href="#module-theory.printer">theory.printer module</a></li>
<li><a class="reference internal" href="#module-theory.slhaDecomposer">theory.slhaDecomposer module</a></li>
<li><a class="reference internal" href="#module-theory.theoryPrediction">theory.theoryPrediction module</a></li>
<li><a class="reference internal" href="#module-theory.topology">theory.topology module</a></li>
<li><a class="reference internal" href="#module-theory">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">SModelS Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="experiment.html"
                        title="next chapter">experiment package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/theory.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="experiment.html" title="experiment package"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="SModelS Documentation"
             >previous</a> |</li>
        <li><a href="index.html">SModelS 1.0.3 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Sabine Kraml, Suchita Kulkarni, Ursula Laa, Andre Lessa, Veronika Magerl, Wolfgang Magerl, Doris Proschofsky, Michael Traub, Wolfgang Waltenberger.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>