common.c:  100      , /* 1      Mcdm         */
directDet.c:  return nucleusRecoil_stat(Mcdm,vfv,A,Z,J,Sxx_, css,csv00,csv01,csv11,dNdE);
directDet.c:  double Mr=MN*Mcdm/(MN+Mcdm);
directDet.c:  return nucleusRecoil_stat(Mcdm,vfv,A,Z,J,Sxx,
directDet.c:  double Mr=MN*Mcdm/(MN+Mcdm);
neutrino.c:{ double mu=Mcdm/MA;
neutrino.c:                         +(mu/2 -mu*aP*aM - muP*muM)*( erf(aP)-erf(-aM)) + muP*muP*( erf(bP)-erf(-bM))*exp(-Mcdm/(2*T)*(v*v-w*w)));  
neutrino.c:  mu=Mcdm*mp_gev/(Mcdm+mp_gev); 
neutrino.c:    mu=Mcdm*MA/(Mcdm+MA);
neutrino.c:    muX=(Mcdm-MA)*(Mcdm-MA)/(4*Mcdm*MA);
neutrino.c:    if(i==0) FFalpha=0; else FFalpha=Mcdm*MA*pow((0.91*pow(MA,0.3333333) +0.3)*GeVfm,2)/3;
neutrino.c://printf("C%d = %E  \n",A[i],rhoDM/Mcdm*cI);
neutrino.c://printf("Sun capture =%E\n",rhoDM*sumI/Mcdm);  
neutrino.c:  return  rhoDM*sumI/Mcdm;
neutrino.c:  mu=Mcdm*mp_gev/(Mcdm+mp_gev); 
neutrino.c:    mu=Mcdm*MA/(Mcdm+MA);
neutrino.c:    mu=Mcdm*MA/(Mcdm+MA);
neutrino.c:    mu=Mcdm*MA/(Mcdm+MA);
neutrino.c:    muX=(Mcdm-MA)*(Mcdm-MA)/(4*Mcdm*MA);
neutrino.c:    FFalpha=Mcdm*MA*pow((0.91*pow(MA,0.3333333) +0.3)*GeVfm,2)/3; 
neutrino.c://printf("C%d = %E  \n",A[i],rhoDM/Mcdm*cI);
neutrino.c:  return  rhoDM*sumI/Mcdm;
neutrino.c:    mu=Mcdm*MA/(Mcdm+MA);
neutrino.c:  double Mr=MN*Mcdm/(MN+Mcdm);
neutrino.c:      r=v0*cs23(cc23,1,v0*Mcdm/2,i3W)/br;
neutrino.c:        r*=decayPcmW(2*Mcdm,m[l],m[l_],wV,wV2,0)/decayPcmW(2*Mcdm,m[l],m[l_],wV,0,0);
neutrino.c:       r_= sqrt(6*T/(Gconst*100*rho*Mcdm))/M_PI;
neutrino.c:     v_=sqrt(8*T/(M_PI*Mcdm));
neutrino.c:     ph=phiTab[0]*Mcdm/T;
neutrino.c:     Veff=pow(Gconst*100*rho*Mcdm/T/3,-1.5);
neutrino.c:   double rho,Mcdm;
neutrino.c:   if(nu && Nu) Mcdm=nu[0]>Nu[0]?nu[0]:Nu[0];
neutrino.c:   else if(nu) Mcdm=nu[0]; else if(Nu) Mcdm=Nu[0]; else return;
neutrino.c:   mu[0]=Mcdm;
neutrino.c:   {  Emu_stat=Mcdm*exp(Zi(i));
neutrino.c:           mu[i]+=simpson(integrandEnuUpward,1/Mcdm,1/Emu_stat,1.E-4);
neutrino.c:           if(sigma) sigma[i]+=simpson(integrandEnuUpward_sigma,1/Mcdm,1/Emu_stat,1.E-4);
neutrino.c:  {  Emu_stat=Mcdm*exp(Zi(i));
neutrino.c:         mu[i]+=simpson(integrandEnuContained,1/Mcdm, 1/Emu_stat,1.E-4);
omega.c:    double A=Mcdm/T*(inMass[k]-Mcdm)/Mcdm   ;
omega.c:    if(A>15 || Mcdm +inMass[k] > MassCut) return sum;
omega.c:    sum+=inG[k]*pow(inMass[k]/Mcdm,1.5)*exp(-A)*K2pol(1/(Mcdm/T+A));
omega.c:   return K1pol(T/(Mcdm*y_pass))*exp((1/T-1/T_)*(2-y_pass)*Mcdm)*sqrt(Mcdm/T)*heff/sqrt(geff)/(gf*gf*s3);
omega.c:   y=sqrtS/Mcdm;
omega.c:   res0=sqrt(2*y/M_PI)*y*(PcmIn*PcmIn/(Mcdm*Mcdm))*sv_tot*6*u*z*z;
omega.c:   if(exi) { return res0*weight(sqrtS/Mcdm); } else return  res0*K1pol(T_/sqrtS)*sqrt(Mcdm/T_);
omega.c:   y=sqrtS/Mcdm;
omega.c:   res0=sqrt(y/(2*M_PI))*y*(PcmIn/Mcdm)*sv_tot*6*u*z*z;
omega.c:   if(exi)  return res0*weight(y);  else  return res0*K1pol(T_/sqrtS)*sqrt(Mcdm/T_);
omega.c:  Mcdm=Mcdm1=Mcdm2=0;
omega.c:  Mcdm=fabs(*(inMassAddress[0]));
omega.c:    if(Mcdm>inMass[i]) Mcdm=inMass[i];
omega.c:  { *Qaddress=2*Mcdm;
omega.c:  GGscale=2*Mcdm/3;
omega.c:  Mcdm=inMass[LSP];
omega.c:  double MassCutOut=MassCut+Mcdm*log(100.)/X;
omega.c:  if(MassCutOut<Mcdm*(2+10/X)) MassCutOut=Mcdm*(2+10/X); 
omega.c:  T_=Mcdm/X;
omega.c:  { int k1=sort[l1]; if(Mcdm+inMass[k1]>MassCut) break;
omega.c:    Msmall=M1>M2? M1-Mcdm*(1-sWidth): M2-Mcdm*(1-sWidth);
omega.c:    Mlarge=M1>M2? M2+Mcdm*(1-sWidth): M1+Mcdm*(1-sWidth);
omega.c:         for(i=0;i<2;i++){ x[i]=sqrt(x[i]); f[i]*=2*x[i]/Mcdm;}
omega.c:         f[0]= c[0]*2*x[0]/Mcdm;
omega.c:    factor=inC0[k1*NC+k2]*inG[k1]*inG[k2]*exp(-(M1+M2 -2*Mcdm)/T_);
omega.c:      if(pmass[0]<Mcdm/2 || pmass[1]<Mcdm/2) continue; 
omega.c:            int c_a =  (pmass[0]>Mcdm) || (pmass[1]>Mcdm);
omega.c:                    if( pmass[0]+pmass[1]>=pmass[l_]) Pcm0=Mcdm*0.01; else 
omega.c:      for(kk=2;kk<4;kk++) if(pmass[kk]>2*Mcdm && pname[kk][0]!='~')
omega.c:  if(!average) { double gf=geffDM(Mcdm/X);  Sum/=gf*gf; Sum1/=gf*gf;   }
omega.c:    double X=Mcdm/T;
omega.c:    if(assignVal("Q",2*Mcdm+T)==0) calcMainFunc();
omega.c:    GGscale=(2*Mcdm+T)/3; 
omega.c:    MassCut=Mcdm*(2-log(Beps)/X);    
omega.c:   double X=Mcdm/T;
omega.c:  double X=Mcdm/T;
omega.c:    MassCut=Mcdm*(2-log(Beps)/X);
omega.c:    MassCut=Mcdm*(2-log(Beps)/XX);  
omega.c:    MassCut=Mcdm*(2-log(Beps)/XX);
omega.c:  MassCut=2*Mcdm-T*log(Beps);
omega.c://  sqrt_gStar=polint2(Mcdm/X,Tdim,t_,sqrt_gstar_);
omega.c:  ddY=dY(polint2(Mcdm/X,Tdim,t_,s3_) ,Beps,Fast); if(FError || ddY==0)  return -1;
omega.c:  if(fabs(CCX-ddY)<dCCX) { *Xf=X; MassCut=Mcdm*(2-log(Beps)/X); return Yeq(Mcdm/X)*sqrt(Mcdm/(1+ddY));} 
omega.c:     dCC2=-CCX+dY(polint2(Mcdm/X,Tdim,t_,s3_),Beps,Fast);
omega.c:     if(Mcdm/X>1.E5) return -1;
omega.c:     dCC1=-CCX+dY(polint2(Mcdm/X,Tdim,t_,s3_),Beps,Fast); 
omega.c:      {*Xf=X1; MassCut=Mcdm*(2-log(Beps)/X1); return Yeq(Mcdm/X1)*sqrt(1+CCX+dCC1);}
omega.c:      {*Xf=X2; MassCut=Mcdm*(2-log(Beps)/X2); return Yeq(Mcdm/X2)*sqrt(1+CCX+dCC2);}
omega.c:    dCC=-CCX+dY(polint2(Mcdm/X,Tdim,t_,s3_),Beps,Fast);
omega.c:  MassCut=2*Mcdm -T*log(Beps_); yeq=Yeq(T);
omega.c://printf("T=%E alpha=%E\n", Mcdm/x, alpha);     
omega.c:  if(assignVal("Q",2*Mcdm)==0) calcMainFunc();
omega.c:  GGscale=2*Mcdm/3;   
omega.c:  Yi=1/( (Mcdm/Xf)*sqrt(M_PI/45)*MPlank*aRate(Xf, 1,Fast,NULL, NULL,NULL) );
omega.c:  return  2.742E8*Mcdm/(1/Yf +  1/Yi); /* 2.828-old 2.755-new 2.742 next-new */
omega.c:  if(assignVal("Q",2*Mcdm)==0) calcMainFunc() ;
omega.c:  GGscale=2*Mcdm/3;
omega.c:  Tstart=Mcdm/Xt;
omega.c:     return 2.742E8*Mcdm*deltaY;  
omega.c:    yeq=Yeq(Mcdm/Xt);
omega.c:       Tend=Mcdm/Xt;
omega.c:       return 2.742E8*Mcdm*deltaY;
omega.c:    Tend=Mcdm/X2;                                 
omega.c:    s3_t=polint2(Mcdm/Xt,Tdim,t_,s3_);
omega.c:    s3_2=polint2(Mcdm/X2,Tdim,t_,s3_); 
omega.c://    if(odeint(&y,1 ,Mcdm/Xt , Mcdm/X2 , 1.E-3, (Mcdm/Xt-Mcdm/X2 )/2, &XderivLn)){ printf("problem in solving diff.equation\n"); return -1;}   
omega.c:  Yi=1/( (Mcdm/Xt)*sqrt(M_PI/45)*MPlank*aRate(Xt,1,Fast,NULL,NULL,NULL));
omega.c:    return  2.742E8*Mcdm/(1/Yt  +  1/Yi); /* 2.828-old 2.755-new,2.742 -newnew */
omega.c:     return 2.742E8*Mcdm*Y0;
omega.c:  MassCut=Mcdm*(2-log(Beps)/Xf);
omega.c:  Sum=aRate(Xf, 1,1,NULL,&omegaCh,&nPrc)*(Mcdm/Xf)*sqrt(M_PI/45)*MPlank/(2.742E8*Mcdm);
omega.c:  MassCut=Mcdm*(2-log(Beps)/Xf);
omega.c:  Sum=aRate(Xf, 1,1,NULL,&wPrc,&nPrc)*(Mcdm/Xf)*sqrt(M_PI/45)*MPlank/(2.742E8*Mcdm);
omega.c:  double X=Mcdm/T;
omega.c:    Msmall=M1>M2? M1-Mcdm*(1-sWidth): M2-Mcdm*(1-sWidth);
omega.c:    Mlarge=M1>M2? M2+Mcdm*(1-sWidth): M1+Mcdm*(1-sWidth);
omega.c:            int c_a =  (pmass[0]>Mcdm) || (pmass[1]>Mcdm);
omega.c:                    if( pmass[0]+pmass[1]>=pmass[l_]) Pcm0=Mcdm*0.01; else 
omega.c:          if(pmass[kk]> 2*Mcdm && z4[kk]!=1 && abs(pdg[kk])!=24 && pdg[kk]!=23 ) 
propagate.c:  if(CDM1==NULL && CDM2==NULL) N=rhoDM/Mcdm;
propagate.c:    if(Es>=Mcdm) buff[i]=0; else
spectra.c:  if(Mcdm0 < 2) printf("WARNING! Spectra obtained at Mcdm=2GeV are used !\n");	 
wPolar.c:  double GG=sqrt(4*M_PI*parton_alpha(2*Mcdm));
wPolar.c:  if(m[0]+m[1]<=2*m[iW]) { printf("Mcdm too low\n"); return 3;}
